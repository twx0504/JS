<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>02-Object - Object.assign</title>
  </head>
  <body>
    <script>
      // Object.assign(target, src1, src2, ...)

      const obj1 = { a: 1, b: 2 };
      const obj2 = { c: 3, d: 4 };

      // this modifies obj1 by merging obj2 to obj1.
      // Note: the return value is the target itself.
      //   const res = Object.assign(obj1, obj2); // merge obj2 to obj1 (target)
      //   console.log(obj1); // {a: 1, b: 2, c: 3, d: 4} // note: without using res, obj1 has already been modified.
      //   console.log(obj1 === res); // true

      //   const obj = { ...obj1, ...obj2 }; // spread obj1 & obj2 props into a new {}.
      //   console.log(obj); // {a: 1, b: 2, c: 3, d: 4}
      //   console.log(obj === obj1); // false

      // We can use Object.assign to achieve { ...obj1, ...obj2 }
      const obj = Object.assign({}, obj1, obj2);
      console.log(obj); // {a: 1, b: 2, c: 3, d: 4}
      console.log(obj === obj1); // false

      // #1: If Object.assign only has an argument. - it did nothing, and return the target as is.
      const test = { a: 1 };
      const obj3 = Object.assign(test);
      console.log(obj3, obj3 === test); // {a: 1} true

      // Primitive converts to wrapper object of the corresponding type.
      console.log(Object.assign(2)); // Number {2}

      console.log(Object.assign("Hello")); // String {'Hello'}

      // Note: null & undefined do not have wrapper object and cannot be converted to wrapper object.
      // console.log(Object.assign(null)); // Uncaught TypeError: Cannot convert undefined or null to object
      // console.log(Object.assign(undefined)); // Uncaught TypeError: Cannot convert undefined or null to object

      // #2: Source

      const test2 = { a: 1, b: 2 };

      // Note: null & undefined as source will not throw error.
      Object.assign(test2, 1, "hello", true, null, undefined, true);
      // Note: Only string wrappers can have own enumerable properties.
      console.log(test2); // {0: 'h', 1: 'e', 2: 'l', 3: 'l', 4: 'o', a: 1, b: 2}

      //  #3: Source property will overwrite the target property if they have a property with the same key.
      // Note: the overwriting is from back to front.
      const test3 = {
        color: ["red", "black"],
        a: 1,
        b: 2,
        c: 3,
        d: 100,
      };
      const test4 = {
        color: ["white", "orange"],
        a: 3,
        b: 4,
      };
      Object.assign(test3, test4, { c: 5 });
      console.log(test3);
      //   {
      //     color: ["white", "orange"], // has been overwritten.
      //     a: 3,  // has been overwritten.
      //     b: 4,  // has been overwritten.
      //     c:5,  // has been overwritten.
      //     d:100
      //   }

      // #4: It is Shallow Copy - be careful if the key contains a reference data type.
      console.log(test3["color"] === test4["color"]); // true

      // #5: Enumerable own property (including Symbol type) - it also do not copy properties from the prototype chain.
      const test5 = {
        a: 1,
        b: 2,
      };
      const test6 = {
        c: 3,
        [Symbol("key")]: "A symbol key",
      };

      Object.defineProperty(test6, "name1", {
        value: "test6",
        // All these configurations below are false by default.
        writable: true,
        configurable: false,
        enumerable: false, // this will not appear on the target.
      });

      Object.defineProperty(test6, "name2", {
        value: "test6",
        // All these configurations below are false by default.
        writable: true,
        configurable: false,
        enumerable: true, // this will be appear on the target.
      });

      Object.assign(test5, test6);
      console.log(test5); // {a: 1, b: 2, c: 3, name2: 'test6', Symbol(key): 'A symbol key'}

      // #6: Getter & Setter of Source

      const test7 = {
        a: 1,
        b: 2,
      };
      const test8 = {
        _x: "a",

        get x() {
          return this._x;
        },

        set x(v) {
          if (v === 3) {
            throw new Error("x cannot be 3.");
          }
          this._x = v;
        },
      };

      // test8.x = 3; // Uncaught Error: x cannot be 3.
      test8.x = 10;
      Object.assign(test7, test8);
      // Note: the getter and setter x becomes data property with the return value of getter.
      console.log(test7); // {a: 1, b: 2, _x: 10, x: 10}
      //   test7.x = 3; // No more error.

      // APPLICATION: Merge default parameters with user parameters

      const userInfo = (userOptions) => {
        const DEFAULTS = {
          username: "guest",
          age: 0,
          sex: "male",
        };
        const options = Object.assign({}, DEFAULTS, userOptions);
        // Alternative:
        // const options ={...DEFAULTS, ...userOptions}
        console.log(options);
      };
      userInfo(); // {username: 'guest', age: 0, sex: 'male'}
      userInfo({}); // {username: 'guest', age: 0, sex: 'male'}
      userInfo({ username: "twx" }); // {username: 'twx', age: 0, sex: 'male'}
      console.log(userInfo({ username: "ljy", age: 25, sex: "female" })); // {username: 'ljy', age: 25, sex: 'female'}
    </script>
  </body>
</html>
