<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Test</title>
  </head>
  <body>
    <script>
      function _typeof(o) {
        "@babel/helpers - typeof";
        return (
          (_typeof =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (o) {
                  return typeof o;
                }
              : function (o) {
                  return o &&
                    "function" == typeof Symbol &&
                    o.constructor === Symbol &&
                    o !== Symbol.prototype
                    ? "symbol"
                    : typeof o;
                }),
          _typeof(o)
        );
      }
      function _callSuper(t, o, e) {
        return (
          (o = _getPrototypeOf(o)),
          _possibleConstructorReturn(
            t,
            _isNativeReflectConstruct()
              ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor)
              : o.apply(t, e)
          )
        );
      }
      function _possibleConstructorReturn(t, e) {
        if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
        if (void 0 !== e)
          throw new TypeError(
            "Derived constructors may only return object or undefined"
          );
        return _assertThisInitialized(t);
      }
      function _assertThisInitialized(e) {
        if (void 0 === e)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return e;
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(
            Reflect.construct(Boolean, [], function () {})
          );
        } catch (t) {}
        return (_isNativeReflectConstruct =
          function _isNativeReflectConstruct() {
            return !!t;
          })();
      }
      function _superPropSet(t, e, o, r, p, f) {
        return _set(_getPrototypeOf(f ? t.prototype : t), e, o, r, p);
      }
      function set(e, r, t, o) {
        return (
          (set =
            "undefined" != typeof Reflect && Reflect.set
              ? Reflect.set
              : function (e, r, t, o) {
                  var f,
                    i = _superPropBase(e, r);
                  if (i) {
                    if ((f = Object.getOwnPropertyDescriptor(i, r)).set)
                      return f.set.call(o, t), !0;
                    if (!f.writable) return !1;
                  }
                  if ((f = Object.getOwnPropertyDescriptor(o, r))) {
                    if (!f.writable) return !1;
                    (f.value = t), Object.defineProperty(o, r, f);
                  } else _defineProperty(o, r, t);
                  return !0;
                }),
          set(e, r, t, o)
        );
      }
      function _set(e, r, t, o, f) {
        if (!set(e, r, t, o || e) && f)
          throw new TypeError("failed to set property");
        return t;
      }
      function _superPropGet(t, o, e, r) {
        var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e);
        return 2 & r && "function" == typeof p
          ? function (t) {
              return p.apply(e, t);
            }
          : p;
      }
      function _get() {
        return (
          (_get =
            "undefined" != typeof Reflect && Reflect.get
              ? Reflect.get.bind()
              : function (e, t, r) {
                  var p = _superPropBase(e, t);
                  if (p) {
                    var n = Object.getOwnPropertyDescriptor(p, t);
                    return n.get
                      ? n.get.call(arguments.length < 3 ? e : r)
                      : n.value;
                  }
                }),
          _get.apply(null, arguments)
        );
      }
      function _superPropBase(t, o) {
        for (
          ;
          !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));

        );
        return t;
      }
      function _getPrototypeOf(t) {
        return (
          (_getPrototypeOf = Object.setPrototypeOf
            ? Object.getPrototypeOf.bind()
            : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t);
              }),
          _getPrototypeOf(t)
        );
      }
      function _inherits(t, e) {
        if ("function" != typeof e && null !== e)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (t.prototype = Object.create(e && e.prototype, {
          constructor: { value: t, writable: !0, configurable: !0 },
        })),
          Object.defineProperty(t, "prototype", { writable: !1 }),
          e && _setPrototypeOf(t, e);
      }
      function _setPrototypeOf(t, e) {
        return (
          (_setPrototypeOf = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          _setPrototypeOf(t, e)
        );
      }
      function _classCallCheck(a, n) {
        if (!(a instanceof n))
          throw new TypeError("Cannot call a class as a function");
      }
      function _defineProperties(e, r) {
        for (var t = 0; t < r.length; t++) {
          var o = r[t];
          (o.enumerable = o.enumerable || !1),
            (o.configurable = !0),
            "value" in o && (o.writable = !0),
            Object.defineProperty(e, _toPropertyKey(o.key), o);
        }
      }
      function _createClass(e, r, t) {
        return (
          r && _defineProperties(e.prototype, r),
          t && _defineProperties(e, t),
          Object.defineProperty(e, "prototype", { writable: !1 }),
          e
        );
      }
      function _defineProperty(e, r, t) {
        return (
          (r = _toPropertyKey(r)) in e
            ? Object.defineProperty(e, r, {
                value: t,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[r] = t),
          e
        );
      }
      function _toPropertyKey(t) {
        var i = _toPrimitive(t, "string");
        return "symbol" == _typeof(i) ? i : i + "";
      }
      function _toPrimitive(t, r) {
        if ("object" != _typeof(t) || !t) return t;
        var e = t[Symbol.toPrimitive];
        if (void 0 !== e) {
          var i = e.call(t, r || "default");
          if ("object" != _typeof(i)) return i;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === r ? String : Number)(t);
      }
      var A = /*#__PURE__*/ (function () {
        function A() {
          _classCallCheck(this, A);
        }
        return _createClass(A, null, [
          {
            key: "foo",
            value: function foo() {
              console.log("foo");
              console.log(this);
            },
          },
        ]);
      })();
      _defineProperty(A, "count", 33);
      var B = /*#__PURE__*/ (function (_A2) {
        function B() {
          _classCallCheck(this, B);
          return _callSuper(this, B, arguments);
        }
        _inherits(B, _A2);
        return _createClass(B, null, [
          {
            key: "bar",
            value: function bar() {
              // super refers to Parent Class
              // similar to A.foo()
              _superPropGet(B, "foo", this, 2)([]);

              // super refers to parent class.
              console.log(_superPropGet(B, "count", this));

              // super refers to this child class.
              _superPropSet(B, "count", 100, this, 1);

              // super still refers to parent class.
              console.log(_superPropGet(B, "count", this));

              // we cannot inspect super. we must specify what form we want to use: function / object.
              // console.log(super); // Uncaught SyntaxError: 'super' keyword unexpected here
            },
          },
        ]);
      })(A);
    </script>
  </body>
</html>
