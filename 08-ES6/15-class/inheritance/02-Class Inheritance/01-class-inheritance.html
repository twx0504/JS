<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>01-Class Inheritance</title>
  </head>
  <body>
    <script>
      class Person {
        #num = 4;
        foo = "foo";
        static count = 33;
        static skills = ["sleep", "eat", "have fun"];
        test = [];
        constructor(name, age) {
          // {}
          // this = {}
          // run the following code and add properties.
          console.log("Parent constructor runs...");
          console.log(this.foo);
          this.name = name;
          this.age = age;

          // Why does Parent "this" looks like Student {}?
          console.log(this); // Student {test: Array(0), name: 'twx', age: 25, #num: 4}
          // "this" will be used by Student so it "decorates" as "Student".
          // but Parent "this" and Student "this" will never equal!
        }

        sayHello() {
          console.log(`Hi, I am ${this.name}, I am ${this.age} years old.`);
        }
      }

      // In ES6, class inheritance is achieved via "extends" keyword.
      // Student inherits properties & method from Person class.
      // Child class doesn't have this, it gets this from super().
      class Student extends Person {
        constructor(name, age, school, sid) {
          console.log("Child constructor runs...");
          // super must be called before you can access this (At this moment, "this" doesn't exist yet).
          // This inherits the instance property from the parent.

          // Attempting to access this throws error.
          // console.log(this); // Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor

          super(name, age);

          // Instead of calling super(), the following code fails the purpose of inheritance.
          // this.name = name;
          // this.age = age;

          this.school = school;
          this.sid = sid;
          // at this point, this exists.
          // console.log(this);
          Student.count++;
          Student.skills.push("exam");
        }

        exam() {
          // private property will not be inherited by the child.
          // private means personal thing.
          // console.log(this.#num); // Uncaught SyntaxError: Private field '#num' must be declared in an enclosing class
          console.log(`${this.name} is in the exam.`);
        }
      }

      const twx = new Student("twx", 25, "UM", "S001");
      // const ljy = new Student("ljy", 24, "UM", "S002");
      console.log(twx); // StudentÂ {name: 'twx', age: 25, school: 'UM', sid: 'S001'}
      twx.sayHello(); // Hi, I am twx, I am 25 years old.
      twx.exam(); // twx is in the exam.

      // The inheritance of static property is shallow copy.
      // Be ware of the reference data type.

      console.log(Student.count === Person.count); // false
      console.log(Student.count, Person.count); // 33 34
      console.log(Student.skills === Person.skills); // true
      console.log(Student.skills, Person.skills); // ['sleep', 'eat', 'have fun', 'exam']  ['sleep', 'eat', 'have fun', 'exam']
      // console.log(twx.test === ljy.test); // false

      // 1. Why do we use super() in child constructor?
      // - super() is used to initialize a shared this object. Both parent and child work on the same object by adding their props.
      // - parent first, child later (Inheritance first, instance later) - inherits all props from parent, and later deal with own props.
      // - So, child's this must be obtained after super().
      // - Execution flow: child constructor runs -> hit super() and pauses -> parent constructor runs -> child constructor resumes.

      // 2. Note: We cannot access this before super() in child constructor.

      class Teacher extends Person {
        // we can neglect writing constructor.
        // It will be added automatically, and call super() for us.
        // constructor(){
        //   super();
        // }
        // Note: however, you manually add constructor, you must remember to call super()!.
      }

      const t1 = new Teacher();

      // ES5 Inheritance: Instance first, inheritance later. The opposite from class inheritance.
      function A() {}
      function B() {
        // borrow Parent constructor to get the parent props.
        A.call(this);
      }
    </script>
  </body>
</html>
