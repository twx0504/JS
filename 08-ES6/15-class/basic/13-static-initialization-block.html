<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>13-Static Initialization Block</title>
  </head>
  <body>
    <script>
      // class A {
      //     count;
      //     #num;
      //     say(){}
      //     // This is not working.
      //     // console.log(1);
      // }

      class A {
        static num = 3;
        // 0 str = "like"
        // 1 str = "dislike"
        static rand = Math.floor(Math.random() * 2);
        // if str is dependent on rand to get the value?

        // #1: If the logic is simple, you can do something like this:
        // static str = A.rand === 0 ? "like" : "dislike";

        // # 2: If the logic is complex, and you want to do something like the following, this isn't allowed.
        // If you want to write it inside the class, use static initialization block.
        //   if (A.rand === 0) {
        //       A.str = "Like";
        //   } else {
        //       A.str = "Dislike";
        //   }

        // constructor() {
        //   // # 3:
        //   // It seems working but we cannot access A.str unless we creates an instance from this class.
        //   // And it will run everytime we create another instance.
        //   // But most of the case, we only want it to evaluate only once.
        //   if (A.rand === 0) {
        //     A.str = "Like";
        //   } else {
        //     A.str = "Dislike";
        //   }
        // }

        // # 4: Static Initialization Block - allows us to write complex logics and codes inside classes.
        // only execute once during class evaluation.
        // multiple static initialization block is allowed, evaluated in the order they are declared.
        // variable declared inside the block is local to the block - including var, let, const, function, etc.
        static {
          // it can only access the property before this block, not after this block.
          // this is because code is evaluated from top to bottom.
          console.log(this.num);
          console.log(this === A); // true.  note: this inside the static initialziation block refers to the class itself.
          if (this.rand === 0) {
            this.str = "Like";
          } else {
            this.str = "Dislike";
          }

          //   return; // return statement is not allowed inside the block.
        }

        static {
          console.log("another static initialization block");
        }

        // note: if the static num is declared after the static initialization block, the console.log(A.num) returns undefined.
        // static num = 3;
      }

      // # 5: Without static initialization block, these kind of codes can be written outside.
      // You can only do it outside, but it is not ideal and it is counter-intuitive.
      //   if (A.rand === 0) {
      //     A.str = "Like";
      //   } else {
      //     A.str = "Dislike";
      //   }

      console.log(A.rand, A.str);
      const a = new A();
      console.log(A.rand, A.str);

      // Function of the Static Initialization Block:
      // 1. resolve the problem regarding initialization of static property.
      // 2. share private property with code outside the class.
      // 3. Application: event delegation code can be written inside the block - shared logic, independent data from each instance.
      //   - example, class creating ball. Each ball has a click event and show something. It is not logic to create new click handler just for each one. We can share the logic.

      let getMoney;

      class Person {
        #money = 200000; // if we want to share this private property with external code, we can use static initialization block.

        static {
          // Important: obj is the instance of the Person class.
          // Because only the instance of this Person class can have access to the private property.
          // lexical scope.
          // this func retains access to the private property because of where it is defined, not where it is called from.
          getMoney = (obj) => obj.#money; // this function is assigned to the external variable, but this function is in fact declared inside the class, so naturally it has the access to the private property.
          //   getMoney = function (obj) {
          //     return obj.#money;
          //   };
        }
      }
      console.log(getMoney(new Person())); // 200000
    </script>
  </body>
</html>
