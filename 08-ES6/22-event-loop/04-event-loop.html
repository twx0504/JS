<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>04-Event Loop - Value returned in then() handlers</title>
  </head>
  <body>
    <script>
      let DELAY_TICK = 0;
      let TOTAL_TICK = 0;

      // Info:
      // - return value in handler callback of then() will have different behaviours.
      // - 1. return plain value -> immediately
      // - 2. return thenable -> additional one tick
      // - 3. return promise -> additional two ticks - which is causing all the confusion.
      // Among three cases, returning a promise is the slowest.
      // https://github.com/tc39/proposal-faster-promise-adoption?tab=readme-ov-file
      // There's a proposal requests the change to faster promise adoption.

      // -----
      // - This step happens after all the synchronous task has been settled.
      // - Case 1: Returns a promise in then() - p4.then(fn) is called as microtask and it schedules another microtask, at this moment p0 is still not yet resolved!!! This results in one more tick.
      // MicrotaskQueue: [0, 1, p4.then((data)=>{fulfill p0 with data}), 2, (data)=>{fulfill p0 with data}, 3, 4, 5, 6]
      //
      // Outcome: 0 1 2 3 4 5 6
      //
      // -----
      // - Case 2: Returns a thenable in then(). - thenable.then(onFulfilled, onRejected) is called as microtask AND it does not schedule microtask because either the onFulfilled or onRejected is called immediately.
      // MicrotaskQueue: [0, 1, thenable.then(onFulfilled, onRejected), 2, 4, 3, 5, 6]
      // Outcome: 0 1 2 4 3 5 6
      // ----
      // - Case 3: Returns a plain value in then(). - resolves immediately
      // MicrotaskQueue: [0, 1, 4, 2, 3, 5, 6]
      // Outcome: 0 1 4 2 3 5 6
      // ----

      // -----
      // pr1 FULFILLED
      // p0 PENDING -> FULFILLED
      // pres PENDING -> FULFILLED
      // ----

      // Note: Each then will create a new promise.
      const pr1 = Promise.resolve()
        .then(() => {
          TOTAL_TICK++;
          // then a
          console.log("=".repeat(20));
          console.log("then a:", 0);
          console.log(`TOTAL TICK: ${TOTAL_TICK} / 7`);
          console.log("=".repeat(20));

          // Return a promise in then() -> the outer promise p0 have to wait for the inner promise to resolve first and adopt its state.
          // Based on Promise A+ specification, the implementation of how promise adopts the inner promise state is not specified and it is up to how JS engine implements the adoption process.
          // Does it happen synchronously or asynchronously? Maybe you can only find the info in the ECMAScript or the source code.
          // Let p4 be the new promise returned by Promise.resolve(4) in p0.then() and internally it will call the p4.then() method.
          // as if p4.then((data)=>{fulfill p0 with data})
          // The whole p4.then() is first put in the microtask. (Additional Tick 1)
          // The (data)=>{fulfill p0 with data} callback will be scheduled later after the microtask p4.then() is executed. (Additional Tick 2)
          // When (data)=>{fulfill p0 with data} is executed and it will fulfill p0 with data.
          // p0.then() will be called and scheduled the callback.

          // #1: Returning a Promise
          // return Promise.resolve(4);

          // What Promise.resolve(4) may looks like UNDER THE HOOD: It perform then() on promise returned by Promise.resolve(4):
          // return new Promise((resolve, reject) => {
          //   Promise.resolve(4)
          //     .then((data) => {
          //       // HIDDEN - this is a hidden then method we have to consider.
          //       console.log("Happens during TICK:", TOTAL_TICK);
          //       // Note: In dev tool, after this line of code is run, it doesn't resolve the p0 immediately. This resolve() likely involves another microtask.
          //       resolve(data);
          //     })
          //     .catch((err) => {
          //       reject(err);
          //     });
          // });

          // #2: Returning a Thenable - Based on my analysis on dev tool, it behaves a bit like Promise, except that when onFulfilled(4) is called in then(), it immediately resolves p0.
          // - for Promise, it will schedule one more microtask - causing the one-more-tick delay.
          // const thenable = {
          //   then(onFulfilled, onRejected) {
          //     onFulfilled(4); // This immediately resolves thenable.
          //   },
          // };
          // return thenable;

          // #3: Returning a Plain Value - immediately (synchronously) resolves the p0.
          return 4;
        })
        .then((res) => {
          // then b - It looks like this callback occurs after then 3.
          // Based on my analysis: it is occurs before then 3.
          TOTAL_TICK++;
          console.log("Additional Delay Tick", DELAY_TICK);
          console.log("then b:", res);
          console.log(`TOTAL TICK: ${TOTAL_TICK} / 7`);
          console.log("=".repeat(20));
        });

      // -----
      // pr2 FULFILLED
      // p1 PENDING -> FULFILLED
      // p2 PENDING -> FULFILLED
      // p3 PENDING -> FULFILLED
      // p4 PENDING -> FULFILLED
      // p5 PENDING -> FULFILLED
      // p6 PENDING -> FULFILLED
      // ----

      const pr2 = Promise.resolve()
        .then(() => {
          // then 1
          TOTAL_TICK++;
          console.log("then 1:", 1);
          console.log(`TOTAL TICK: ${TOTAL_TICK} / 7`);
          console.log("=".repeat(20));
        })
        .then(() => {
          // then 2
          TOTAL_TICK++;
          DELAY_TICK++;
          console.log("then 2:", 2);
          console.log(`TOTAL TICK: ${TOTAL_TICK} / 7`);
          console.log("=".repeat(20));
        })
        .then(() => {
          // then 3
          TOTAL_TICK++;
          DELAY_TICK++;
          console.log("then 3:", 3);
          console.log(`TOTAL TICK: ${TOTAL_TICK} / 7`);
          console.log("=".repeat(20));
        })
        .then(() => {
          // then 4
          TOTAL_TICK++;
          console.log("then 5:", 5);
          console.log(`TOTAL TICK: ${TOTAL_TICK} / 7`);
          console.log("=".repeat(20));
        })
        .then(() => {
          // then 5
          TOTAL_TICK++;
          console.log("then 6:", 6);
          console.log(`TOTAL TICK: ${TOTAL_TICK} / 7`);
          console.log("=".repeat(20));
        });
    </script>
  </body>
</html>
