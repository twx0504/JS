<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>11-Array - Array.of</title>
  </head>
  <body>
    <script>
      // Array.of(ele1, ele2, ele3, ...)
      // similar to new Array()
      // but it resolves the problem of new Array() e.g., new Array(5) means creating an array with 5 empty slots. instead of [5].
      console.log(Array.of(10)); // [10]
      console.log(Array.of(5)); // [5]

      console.log(new Array(5)); // [empty × 5]
      console.log(new Array(10)); // [empty × 10]

      console.log(Array.of(1, 2, 3, 4, 5)); // [1, 2, 3, 4, 5]
      console.log(new Array(1, 2, 3, 4, 5)); // [1, 2, 3, 4, 5]

      console.log(Array.of(1, 2)); // [1, 2]
      console.log(new Array(1, 2)); // [1, 2]

      console.log(Array.of(undefined)); // [undefined]

      // Non-Array constructor that accept length.
      function NotArray(len) {
        console.log(`NotArray is called with length of ${len}`);
      }
      // thisArg is a constructor that accept a single argument representing the length of new array.
      const newArr = Array.of.call(NotArray, 1, 2, 3, 4); // NotArray is called with length of 4.
      console.log(newArr); // NotArray {0: 1, 1: 2, 2: 3, 3: 4, length: 4}

      // thisArg is not a constructor, a plain Array object is returned.
      const newArr2 = Array.of.call({}, 2, 4, 6, 8); // thisArg here is {}.
      console.log(newArr2); // [2, 4, 6, 8]

      // Implement Array.of

      // Array._of = function (...args) {
      //   return [...args];
      // };

      Array._of = function () {
        // return Array.prototype.slice.call(arguments);
        return [].slice.call(arguments); // similar to arguments.slice() meaning copying everything shallowly.
      };

      console.log(Array._of(10, 20, 30)); // [10, 20, 30]
    </script>
  </body>
</html>
