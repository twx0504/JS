<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>10-Array - Array.from</title>
  </head>
  <body>
    <script>
      // Array.from(items)
      // Array.from(items, mapFn)
      // Array.from(items, mapFn, thisArg)

      // - item: array-like object / iterable

      function sum() {
        console.log(arguments);
        const arr = Array.from(arguments);
        console.log(arr);
      }

      sum(1, 2, 3, 4);
      // Arguments(4) [1, 2, 3, 4, callee: ƒ, Symbol(Symbol.iterator): ƒ]
      // [1, 2, 3, 4]

      // Iterable: Set Map NodeList String NodeList
      const set = new Set([2, 4, 6, 8]);
      console.log(Array.from(set)); // [2, 4, 6, 8]
      console.log(Array.from(set.values())); // [2, 4, 6, 8]
      console.log(Array.from(set.entries())); // [[2, 2], [4, 4], [6, 6], [8, 8]]

      const map = new Map([
        ["a", 1],
        ["b", 2],
        ["c", 3],
      ]);
      console.log(Array.from(map));
      //   [
      //     ["a", 1],
      //     ["b", 2],
      //     ["c", 3],
      //   ];
      console.log(Array.from(map.values())); // [1, 2, 3]

      const set2 = new Set([10, 20, 30, 40]);
      const newArr = Array.from(set2, (v) => {}); // note: {} here is code block not an object
      //   const newArr = Array.from(set2, (v) =>({})); // this would be an object we need parentheses.

      console.log(newArr); // [undefined, undefined, undefined, undefined]

      // SIMILAR TO THE FOLLOWING:
      //   const temp = Array.from(set2);
      //   console.log(temp);
      //   const newArr2 = temp.map((v) => {});
      //   console.log(newArr2); // [undefined, undefined, undefined, undefined]
      const newArr2 = Array.from(set2, (v) => v * 2);
      console.log(newArr2); // [20, 40, 60, 80]

      // Array.from will never create sparse array.
      // All empty slots will be replaced by undefined.
      // Note: arr is also an iterable and that's why it is working here.
      const arr = [1, 2, , , , 3, 4, 5, 6, , , , 8];
      console.log(Array.from(arr)); //  [1, 2, undefined, undefined, undefined, 3, 4, 5, 6, undefined, undefined, undefined, 8]

      // Custom Array-Like object
      // - it has length
      // - it has non-negative integer key
      const obj = {
        length: 3,
        0: "a",
        // but we are missing index 1 & 2 so this is technically like a sparse array.
      };
      console.log(Array.from(obj)); // ['a', undefined, undefined]

      console.log(Array.from("Hello World")); //  ['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd']

      // thisArg - third parameter

      const map2 = new Map([
        ["a", 1],
        ["b", 2],
        ["c", 3],
      ]);

      const res = Array.from(
        map2,
        (v, i) => {
          //   console.log(this); // window - arrow function doesn't have this.
          return this[i];
        },
        ["foo", "bar", "zoo"]
      );
      console.log(res); // [undefined, undefined, undefined]

      const res2 = Array.from(
        map2,
        function (v, i) {
          //   console.log(this); // ["foo", "bar", "zoo"]
          return this[i];
        },
        ["foo", "bar", "zoo"]
      );
      console.log(res2); // [undefined, undefined, undefined]

      // Range
      const range = (start, stop, step) =>
        Array.from(
          // Array-like object with length.
          // It ensures the resulting array has the target length based on calculation.
          {
            // e.g.1: 0 (inclusive) -> 10 (exclusive) with 2 step
            // 0 -> 2 -> 4 -> 6 -> 8 (stop before 10 as 10 is not inclusive) so there are 5 elements.
            // (10 - 0) / 2 = 5

            // e.g.2: 0  (inclusive) -> 11 (exclusive) with 2 step
            // 0 -> 2 -> 4 -> 6 -> 8 -> 10 (stop before 11 as 11 is not inclusive) so there are 6 elements.
            // (11 - 0) / 2 = 5.5 = 6 (round up)
            length: Math.ceil((stop - start) / step),
          },
          // this map function is run based on the number of element.
          // Since the array-like object will have length and that length will decide how many element the array will contain.
          // And it decides how many times this mapFn is run.
          (_, i) => {
            console.log(start + i * step);
            return start + i * step;
          }
        );

      console.log(range(0, 5, 1)); // [0, 1, 2, 3, 4]
      console.log(range(0, 10, 2)); // [0, 2, 4, 6, 8]
      console.log(range(0, 11, 2)); // [0, 2, 4, 6, 8, 10]
      console.log(range(1, 10, 2)); // [1, 3, 5, 7, 9]

      // "Z".charCodeAt(0) + 1 because we want to include "Z" char code!
      // Otherwise, we will not get "Z"
      console.log(
        range("A".charCodeAt(0), "Z".charCodeAt(0) + 1, 1).map((v) =>
          String.fromCharCode(v)
        )
      ); // ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']

      //  Array Deduplication & Concat
      function combine() {
        // Similar to const arr = Array.prototype.concat.apply([], arguments);
        // [].concat is just taking the concat method from an empty array (borrowing)
        // the thisArg of apply(thisArgs, ...args) must be an empty array as if this concat method is called upon an empty array.
        // [].concat.apply([], arguments) means thisArg.concat(arg1, arg2, ...) 
        // Where thisArg is the first parameter to apply() (the empty array []), not the original [] we borrowed the method from.
        // Note: thisArg is also participating in the processing!
        const arr = [].concat.apply([], arguments);
        return Array.from(new Set(arr));
      }

      const test = [1, 2, 3];
      const test2 = [2, 3, 4];
      console.log(combine(test, test2)); // [1, 2, 3, 4]
    </script>
  </body>
</html>
