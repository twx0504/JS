<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>04-Reduce</title>
  </head>
  <body>
    <script>
      // reduce(callback)
      // prev = arr[0] - the first call
      // cur = arr[1] - the first call
      const res = [1, 2, 3, 4].reduce((prev, cur, i, arr) => {
        // prev: the last return value
        // cur: the current value to be processed
        // i: the index of the current value
        // arr: the array to be processed.
        console.log(prev, cur, i, arr);
        return prev;
      });

      // 1 2 1 [1, 2, 3, 4]
      // 1 3 2 [1, 2, 3, 4]
      // 1 4 3 [1, 2, 3, 4]

      console.log(res); // 1 - the value when the reducer runs to completion.

      // reduce(callback, initial)
      // prev = initial - the first call
      // cur = arr[0] - the first call

      const res2 = [1, 2, 3, 4].reduce((prev, cur, i, arr) => {
        // prev: the last return value
        // cur: the current value to be processed
        // i: the index of the current value
        // arr: the array to be processed.
        console.log(prev, cur, i, arr);
        return prev;
      }, 100);

      //   100 1 0 [1, 2, 3, 4]
      //   100 2 1 [1, 2, 3, 4]
      //   100 3 2 [1, 2, 3, 4]
      //   100 4 3 [1, 2, 3, 4]

      console.log(res2); // 100

      // Sum of all element
      const res3 = [10, 20, 30, 40].reduce((prev, cur, i, arr) => {
        console.log(prev + cur);
        return prev + cur;
      });

      // 30
      // 60
      // 100

      console.log(res3); // 100

      // max of the array
      const res4 = [1, 2, 10, 4, 5, 40, 1000].reduce((prev, cur, i, arr) => {
        return Math.max(prev, cur);
      });
      console.log(res4); // 1000

      // Count the frequency of element
      //   const res5 = ["a", "b", "a", "c", "b", "d"].reduce(
      //     (prev, cur, i, arr) => {
      //       if (!(cur in prev)) {
      //         prev[cur] = 1;
      //       } else {
      //         prev[cur]++;
      //       }

      //       return prev;
      //     },
      //     {}
      //   );
      //   console.log(res5); // {a: 2, b: 2, c: 1, d: 1}

      const res5 = ["a", "b", "a", "c", "b", "d"].reduce(
        // note:  (prev.get(cur) || 0) ++ would fail because (prev.get(cur) || 0) is an expression not variable. It modifies something and it needs a variable that it can actually change.
        (prev, cur, i, arr) => prev.set(cur, (prev.get(cur) || 0) + 1),
        new Map()
      );
      console.log(res5); // {a: 2, b: 2, c: 1, d: 1}

      // reduce can do many things but there's much better alternative to such cases:
      // One of them being:
      // Deduplicate element (but there's better way)
      const res6 = [1, 1, 1, 3, 4, 4, 5, 6, 6, 8, 10].reduce((prev, cur) => {
        if (!prev.includes(cur)) {
          prev.push(cur);
        }
        return prev;
      }, []);
      console.log(res6); // [1, 3, 4, 5, 6, 8, 10]

      // Alternative:
      const unique = Array.from(new Set([1, 1, 1, 3, 4, 4, 5, 6, 6, 8, 10]));
      console.log(unique); // [1, 3, 4, 5, 6, 8, 10]
    </script>
  </body>
</html>
