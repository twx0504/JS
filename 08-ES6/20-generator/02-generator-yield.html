<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>02-Generator - yield</title>
  </head>
  <body>
    <script>
      // #1: Regular Function cannot use with yield.
      //    function gen2(){
      //       yield 1; // Uncaught SyntaxError: Unexpected number
      //   }

      // #2: `yield` can only appear *directly* inside a generator function body.
      function* gen() {
        yield 1;
        // Case 1: Even if you nest a normal function inside, you cannot use yield there.
        // function foo(){
        //     yield 3; // Uncaught SyntaxError: Unexpected number
        // }

        // Case 2: `yield` also cannot be used inside callbacks like forEach/map/filter
        // because those callback are just normal functions, not generator functions.
        // [100, 200, 300].forEach((v) => {
        //     yield v; // Uncaught SyntaxError: Unexpected identifier 'v'
        // });

        // loop is fine as it is part of the generator function's body.
        for (let i = 100; i < 400; i += 100) {
          yield i;
        }
      }

      for (const v of gen()) {
        console.log(v);
      }

      // 1
      // 100
      // 200
      // 300

      // #2: yield expression where expression is optional.

      function* gen2() {
        console.log(1);
        yield; // same as yield undefined
        console.log(2);
        yield; // same as yield undefined
        yield 4;
      }
      const it = gen2();
      console.log(it.next());
      // 1
      // {value: undefined, done: false}
      console.log(it.next());
      // 2
      // {value: undefined, done: false}
      console.log(it.next());
      // {value: 4, done: false}
      console.log(it.next());
      // {value: undefined, done: true}

      // #3: If yield is part of a larger expression involving operators, parentheses are required.

      function* gen3() {
        // let str = `hello ${yield 3}`; // this is okay without ().

        // Here parentheses are required because '+' is an operator
        let str = `Hi` + (yield 3);
        console.log(str);
        // parentheses required because 'yield' is part of concatenation
        console.log("Greetings" + (yield 5) + str);
      }

      const it2 = gen3();
      console.log(it2.next());
      // {value: 3, done: false}
      console.log(it2.next());
      // Hiundefined
      // {value: 5, done: false}

      console.log(it2.next());
      // GreetingsundefinedHiundefined
      // {value: undefined, done: true}

      // #4: If yield is passed as function arguments or appears on the RHS of the assignment operator(=), parentheses is not needed

      function* gen4() {
        function Foo(foo) {
          console.log("Run after two yield statements");
        }
        // 'Foo' is called only after two .next() calls
        Foo(yield "a", yield "b");

        // Important:
        // Multiple 'yield' in one expression → evaluated step by step (left-to-right).
        // 'yield' has very low precedence, so:
        //   yield 4 + (yield 6) + (yield 5)
        // is parsed as:
        //   yield (4 + (yield 6) + (yield 5))
        //
        // The outer yield yields the *entire sum* as one value.
        // The inner (yield 6) and (yield 5) are evaluated first when the sum is computed.
        //
        // This does NOT "result in NaN" unless you forget to pass numbers
        // when resuming with .next(...). With numeric inputs, you’ll get a valid sum.

        // let num = (yield 4) + (yield 6) + (yield 5); // ensures that the order of yields is exactly what we see: first 4, then 6, then 5.
        let num = yield 4 + (yield 6) + (yield 5);
        // 'yield' on RHS of assignment is fine without ()
        let num2 = yield 7;
        // But if 'yield' is part of an arithmetic expression, () is required:
        // let num2 = 5 + (yield 7);
        console.log(num, num2);
      }

      const it3 = gen4();
      console.log(it3.next()); // {value: 'a', done: false}
      console.log(it3.next()); // {value: 'b', done: false}
      console.log(it3.next());
      // Run after two yield statements
      // {value: 6, done: false}
      console.log(it3.next());
      // {value: 5, done: false}

      console.log(it3.next());
      // {value: NaN, done: false}
      // why NaN, not 4?
      // It is because 4 + undefined + undefined = NaN
      // yield looks at the value behind it.

      console.log(it3.next());
      // {value: 7, done: false}

      console.log(it3.next());
      // undefined undefined
      // {value: undefined, done: true}
    </script>
  </body>
</html>
