<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>08-Generator - return</title>
  </head>
  <body>
    <script>
      //   function* gen() {
      //     yield 1;
      //     yield 2;
      //     yield 3;
      //   }

      //   const it = gen();
      //   console.log(it.next()); // {value: 1, done: false}
      //   console.log(it.next()); // {value: 2, done: false}
      //   console.log(it.return("stop")); // {value: 'stop', done: true}
      //   console.log(it.next()); // {value: undefined, done: true}

      //   for (const v of gen()) {
      //     console.log(v);
      //   }

      //   try {
      //     throw new Error("a");
      //   } catch (e) {
      //     console.log(e);
      //   } finally {
      //     console.log(1); // run regardless of error.
      //   }
      // Error: a
      // 1

      //   function* gen2() {
      //     yield 1;
      //     try {
      //       yield 2;
      //       throw new Error("a");
      //     } catch (e) {
      //       console.log("Internal: ", e);
      //     } finally {
      //       yield 4;
      //       yield 5;
      //     }
      //   }

      //   const it2 = gen2();
      //   console.log(it2.next()); // {value: 1, done: false}
      //   console.log(it2.next()); // {value: 2, done: false}
      //   console.log(it2.next());
      //   // Internal:  Error: a
      //   // {value: 4, done: false}

      // #1: Code has reached the try block, then `return` is called outside.
      // - Before finishing, the generator must execute the `finally` block.
      // - Each `yield` in the finally block is returned step by step.
      // - Only after the finally block is done, the generator fully closes with {done: true}.
      // - The value passed to return("pause") is returned at the very end.
      //   function* gen3() {
      //     yield 1;
      //     try {
      //       yield 2;
      //       throw new Error("a");
      //     } catch (e) {
      //       console.log("Internal: ", e);
      //     } finally {
      //       yield 4;
      //       yield 5;
      //     }
      //   }

      //   const it3 = gen3();
      //   console.log(it3.next()); // {value: 1, done: false}
      //   console.log(it3.next()); // {value: 2, done: false}
      //   // Finishes the iterator(generator).
      //   // Code in Finally Block must be run first, before calling the return method..
      //   console.log(it3.return("pause")); // {value: 4, done: false}
      //   console.log(it3.next()); // {value: 5, done: false}
      //   console.log(it3.next()); // {value: 'pause', done: true}

      // #2: Code has NOT entered the try block yet when `return` is called.
      // - Since try/finally isn’t entered, the finally block won’t run.
      // - The generator ends immediately, returning the passed value with done: true.
      //   function* gen4() {
      //     yield 1;
      //     try {
      //       yield 2;
      //       throw new Error("a");
      //     } catch (e) {
      //       console.log("Internal: ", e);
      //     } finally {
      //       // Because try block is not entered, so the code in finally block is not run.
      //       yield 4;
      //       yield 5;
      //     }
      //   }

      //   const it4 = gen4();
      //   console.log(it4.next()); // {value: 1, done: false}
      //   console.log(it4.return("pause")); // {value: 'pause', done: true}
      //   console.log(it4.next()); // {value: undefined, done: true}
      //   console.log(it4.next()); // {value: undefined, done: true}

      // #3: Generator is already inside finally.
      // - Calling return() here stops it immediately, skipping the rest.
      function* gen5() {
        yield 1;
        try {
          yield 2;
          throw new Error("a");
        } catch (e) {
          console.log("Internal: ", e);
        } finally {
          yield 4;
          // - If return("pause") is called at this point, the generator
          //   will immediately finish, skipping yield 5 and yield 6.
          // - The return() value "pause" is given back with {done: true}.
          // - After that, further next() calls just return {undefined, true}.
          yield 5;
          yield 6;
        }
      }

      const it5 = gen5();
      console.log(it5.next()); // {value: 1, done: false}

      console.log(it5.next()); // {value: 2, done: false}
      console.log(it5.next());
      // Internal:  Error: a
      // {value: 4, done: false}
      console.log(it5.return("pause")); // {value: 'pause', done: true}
      console.log(it5.next()); // {value: undefined, done: true}
    </script>
  </body>
</html>
