<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>06-Generator - throw</title>
  </head>
  <body>
    <script>
      // Different Scenarios of throw:
      // #1: Call it.throw() outside the generator function, with no error handling.
      // The error is uncaught, so the generator terminates immediately.
      // Any code after the error will not run.
      //   function* gen() {
      //     yield 1;
      //     yield 2; // Uncaught throws some errors.
      //     yield 3;
      //     yield 4;
      //     yield 5;
      //   }

      //   const it = gen(); // an iterator
      //   console.log(it.next());
      //   it.throw("throws some errors.");
      //   console.log(it.next()); // not working.

      // #2: Call it.throw() outside the generator function,
      // and handle the error with try...catch outside.
      // The iterator is closed, so further next() calls return {value: undefined, done: true}.
      //   function* gen() {
      //     yield 1;
      //     yield 2; // Uncaught throws some errors.
      //     yield 3;
      //     yield 4;
      //     yield 5;
      //   }

      //   const it = gen(); // an iterator
      //   console.log(it.next());

      //   try {
      //     it.throw("throws some errors.");
      //   } catch (e) {
      //     console.log(e);
      //   }

      //   console.log(it.next()); // {value: undefined, done: true}

      // #3: call it.throw() method outside the generator function and is handled by try...catch within the generator function.
      // the iterator will not closed.
      //   function* gen() {
      //     yield 1;
      //     try {
      //       yield 2; // if an error is thrown here, execution jumps to catch
      //       yield 3;
      //     } catch (e) {
      //       // execution goes here, skipping yield 3
      //       console.log(`Error caught internally: `, e);
      //     }
      //     yield 4; // this will be the throw() return value
      //     yield 5; // the next call to next() will yield 5
      //   }
      //   const it = gen(); // an iterator
      //   console.log(it.next()); // {value: 1, done: false}
      //   console.log(it.next()); // {value: 2, done: false}
      //   // Why do we see yield 4 here?
      //   // Because the error was handled inside try...catch,
      //   // the generator continues after the catch block.
      //   // The return value of it.throw() is like the next it.next(),
      //   // resuming from the next yield after catch.
      //   console.log(it.throw("error"));
      //   // throws into the generator at the paused yield (2)
      //   // jumps to catch block → logs "Error caught internally: error"
      //   // continues after catch → resumes at yield 4
      //   // return value is {value: 4, done: false}

      //   console.log(it.next()); // {value: 5, done: false}
      //   console.log(it.next()); // {value: undefined, done: true}

      // #4: call it.throw() method outside the generator function and is handled by try...catch within and outside the generator function.

      //   function* gen() {
      //     yield 1;
      //     // Internal try...catch
      //     try {
      //       yield 2; // if an error is thrown here, execution jumps to catch
      //       yield 3;
      //     } catch (e) {
      //       // execution goes here, skipping yield 3
      //       console.log("Error caught internally: ", e);
      //     }
      //     // There is no try...catch after this point,
      //     // so a second throw will not be handled inside the generator.
      //     yield 4; // returned as the result of the first it.throw()
      //     yield 5; // would only be reached if no further unhandled throw occurs
      //   }
      //   const it = gen(); // an iterator
      //   console.log(it.next()); // {value: 1, done: false}
      //   console.log(it.next()); // {value: 2, done: false}

      //   // External try...catch
      //   try {
      //     // "error1" is injected into the generator at yield 2
      //     // → handled by the internal catch
      //     // → logs "Error caught internally: error1"
      //     // → resumes after catch → yields 4
      //     // → returns {value: 4, done: false}
      //     console.log(it.throw("error1")); // {value: 4, done: false} - this is caught internally.
      //     // "error2" is injected again, but there is no internal try...catch left
      //     // → error propagates out
      //     // → caught by the external try...catch below
      //     console.log(it.throw("error2"));
      //   } catch (e) {
      //     console.log("Error caught externally:", e);
      //   }

      //   // generator is already closed after external throw
      //   console.log(it.next()); // {value: undefined, done: true} -

      // throw keyword
      // #1: use throw OUTSIDE generator function
      //   function* gen() {
      //     yield 1;
      //     yield 2;
      //     try {
      //       yield 3;
      //     } catch (e) {
      //       console.log(e);
      //     }
      //     yield 4;
      //   }

      //   const it = gen();
      //   console.log(it.next());
      //   console.log(it.next());
      //   console.log(it.next());
      //   // // If you do this,  it will be caught by the generator's try...catch:
      //   // console.log(it.throw("a")); // logs "Caught inside generator: a" → yields 4

      //   // But using the global `throw` keyword here is different:
      //   throw new Error("a");
      //   // This error happens in normal code, NOT inside the generator.
      //   // The generator's internal try...catch cannot see this.
      //   // If unhandled here, the script stops immediately.

      // #2: use throw INSIDE generator function
      //   function* gen() {
      //     yield 1;
      //     yield 2;
      //     try {
      //       throw new Error("a"); //  // exception thrown here immediately
      //       yield 3; // skipped, never executed.
      //     } catch (e) {
      //       console.log(e);
      //     }
      //     yield 4; // execution continues after catch
      //   }

      //   const it = gen();
      //   console.log(it.next()); // {value: 1, done: false}
      //   console.log(it.next()); // {value: 2, done: false}
      //   console.log(it.next());
      //   // Error: a
      //   // {value: 4, done: false}

      // #3: use throw INSIDE generator function BUT not handled internally.
      function* gen() {
        yield 1;
        yield 2;
        throw new Error("a");
        yield 3; // never reach
        yield 4; // never reach
      }
      const it = gen();
      console.log(it.next()); // {value: 1, done: false}
      console.log(it.next()); // {value: 2, done: false}
      try {
        console.log(it.next());
        // When resuming, execution hits `throw new Error("a")`
        // Since there's no try...catch inside the generator,
        // the error bubbles out here.
      } catch (e) {
        console.log(e); // Error: a
      }
      console.log(it.next()); // {value: undefined, done: true}
      // After the unhandled throw, the generator is CLOSED.
      // No further yields are possible.
    </script>
  </body>
</html>
