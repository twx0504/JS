<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>21-Promise - Implement _any</title>
  </head>
  <body>
    <script>
      // [p1, p2, p3, p4, p5] - an iterable of promises
      // ["hello", 1, p1, p2, p3] - what if some member of the iterable is not promise?
      // returns a promise fulfilled with the value of the first promise that fulfills.
      // If all promises are rejected, then returns a promise rejected with the last rejected reason.

      // Pseudo Code:
      //   function _any(iterable) { // note: iterable may not be array. And not all iterable has length property.
      //     let rejectedCount = 0;
      //     let rejectedResult = [];
      //     return new Promise((resolve, reject) => {
      //       for (const promise of iterable) {
      //         promise
      //           .then((data) => {
      //             resolve(data); // If one of the promise first get fulfilled, the returned promise state is determined, and is irreversible.
      //           })
      //           .catch((err) => {
      //             // count the rejected promises.
      //             // Since we wants the last rejected reason, we cannot call reject immediately.
      //             // We need to count until the count equals the length of iterable.
      //             // To get the rejected reason of the last promise that rejected.
      //             rejectedCount++;

      //             // But, how do we ensure the order?
      //             // rejectedResult.push(err);
      //             if (rejectedCount === iterable.length) {
      //               reject(err);
      //               //   reject(rejectedResult);
      //             }
      //           });
      //       }
      //     });
      //   }

      //   _any()
      //     .then((data) => console.log(data))
      //     .catch((err) => console.log(err));

      Promise._any = function (iterable) {
        let rejectedCount = 0;
        let rejectedResult = [];
        return new Promise((resolve, reject) => {
          // check if iterable is undefined or null
          if (iterable === null || iterable === undefined) {
            return reject(new TypeError(`${iterable} is not iterable.`));
          }
          // check the argument is an iterable or iterator with next method.
          if (
            typeof iterable.next !== "function" &&
            typeof iterable[Symbol.iterator] !== "function"
          ) {
            return reject(new TypeError(`${iterable} is not iterable.`));
          }

          for (let p of iterable) {
            // check if p is a promise.
            if (p instanceof Promise) {
              p.then((data) => {
                resolve(data); // why return keyword is needed here?
              }).catch((err) => {
                rejectedCount++;
                if (rejectedCount === iterable.length) {
                  reject(new Error(`Last rejected reason: ${err}`));
                }
              });
            } else {
              // not a promise.
              return resolve(p);
            }
          }

          if (iterable.length === 0) {
            // Even if passing an empty array, we need to change the PromiseState.
            reject(new Error("Iterable is empty."));
          }
        });
      };

      // Promise._any(); // Uncaught (in promise) TypeError: undefined is not iterable.
      Promise._any([]).catch((data) => console.log(data));
      // function* gen() {
      //   yield 1;
      // }

      // const it = gen();
      // Promise._any(it);
      // Promise._any(new Set());

      Promise._any([1, 2, Promise.resolve(3)]).then(
        (data) => console.log(data) // 1
      );
      Promise._any([
        Promise.reject(1),
        Promise.reject(2),
        Promise.reject(3),
      ]).catch((err) => console.log(err)); // Error: Last rejected reason: 3
    </script>
  </body>
</html>
