<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>06-Promise Instance Method: then</title>
  </head>
  <body>
    <script>
      // --- When does the .then() method execute? ---
      // =========================================================
      // Example 1: Immediate resolve inside Promise constructor
      // =========================================================
      // Demonstrates when .then() is executed if the Promise
      // is resolved immediately (synchronously).
      //
      // Task execution order in JS:
      //   1. Synchronous (main thread)
      //   2. Microtasks (e.g., Promise callbacks)
      //   3. Macrotasks (e.g., setTimeout)
      //
      // console.log(1);
      //
      // // Macro task (Async)
      // // The callback will be added to the macrotask queue
      // // and executed after all synchronous and microtasks finish.
      // setTimeout(function () {
      //   console.log(2);
      // }, 0);
      //
      // const p = new Promise((resolve, reject) => {
      //   // The executor function runs immediately (synchronous).
      //   console.log(5);
      //   // Changing Promise state: pending → fulfilled.
      //   // Once resolved, .then() callback is scheduled as a microtask.
      //   resolve(4);
      // });
      //
      // // Microtask (Async)
      // // The callback will be added to the microtask queue,
      // // and executed after the current synchronous code.
      // p.then((data) => {
      //   console.log(data);
      // });
      //
      // console.log(3);
      //
      // // Execution order:
      // // 1 → synchronous
      // // 5 → synchronous inside Promise executor
      // // 3 → synchronous after .then()
      // // 4 → microtask (.then() callback)
      // // 2 → macrotask (setTimeout)
      // // Final Output: 1, 5, 3, 4, 2

      // =========================================================
      // Example 2: Resolve delayed by setTimeout (async resolve)
      // =========================================================

      // console.log(1);

      // // Macrotask #1: schedules to log 2
      // setTimeout(function () {
      //   console.log(2);
      // }, 0);

      // const p = new Promise((resolve, reject) => {
      //   console.log(5);

      //   // Macrotask #2: schedules resolve(4)
      //   // Until resolve() is executed, the Promise remains "pending",
      //   // so .then() won’t run yet.
      //   setTimeout(function () {
      //     resolve(4);
      //   }, 0);
      // });

      // // Registers a microtask callback that will run
      // // once the Promise is fulfilled or rejected.
      // p.then((data) => {
      //   console.log(data);
      // });

      // console.log(3);

      // // Execution breakdown:
      // // 1 → synchronous
      // // 5 → synchronous (inside Promise executor)
      // // 3 → synchronous (after .then())
      // // 2 → first macrotask (logs 2)
      // // 4 → second macrotask triggers resolve()
      // //     → this queues a microtask for .then()
      // //     → .then() runs immediately after that macrotask finishes
      // //
      // // Final Output: 1, 5, 3, 2, 4

      // --- The Short Form of then methods----
      // const p = new Promise((resolve, reject) => {
      //   resolve(2);
      // });

      // // p.then(onFulfilled, onRejected);
      // // p.then(onFulfilled);
      // // p.then(null, onRejected);

      // // Full Form:
      // // p.then((data) => {
      // //   console.log(data);
      // // }, (err) => {});

      // // onRejected is optional.
      // p.then((data) => {
      //   console.log(data); // 2
      // });

      // const p2 = new Promise((resolve, reject) => {
      //   reject(new Error("Rejected."));
      // });

      // p2.then(null, (err) => {
      //   console.log(err); // Error: Rejected.
      // });

      // // --- Return Value of then ---
      // // - return a new Promise object that is fulfilled by default.
      // // - support method chaining because Promise Object contains then method.

      // const p = new Promise((resolve, reject) => {
      //   resolve(2);
      // });

      // // const p1 = p.then((data) => {
      // //   console.log(data);
      // // });
      // // console.log(p1); // Promise {<pending>} -> This promise is "fulfilled"

      // // The returned Promise is fulfilled, that's why the first callback of the then method can run.
      // p.then(() => {
      //   console.log(1);
      // }) // return a fulfilled promise.
      //   .then(() => {
      //     console.log(2);
      //   }) // return a fulfilled promise.
      //   .then(() => {
      //     console.log(3);
      //   }); // return a fulfilled promise.

      // // 1
      // // 2
      // // 3

      // // --- Passing Value Forward in .then() ---
      // const p = new Promise((resolve, reject) => {
      //   resolve(1);
      // });

      // // ==========================================================
      // // Example 1: Basic .then() return behavior
      // // ==========================================================

      // const p1 = p.then((data) => {
      //   console.log(data); // 1
      //
      //   // If you don’t explicitly return a value,
      //   // the callback implicitly returns undefined.
      //   // So the .then() method itself returns
      //   // a new fulfilled Promise with result = undefined.
      //
      //   // return undefined; // (default behavior)
      // });
      //
      // console.log(p1); // A Promise with [[PromiseResult]]: undefined

      // // ==========================================================
      // // Example 2: Chaining multiple .then() methods
      // // ==========================================================
      // //

      // p.then((data) => {
      //   console.log(data);
      //   return 10; // This value will be passed to the next .then()
      // })
      //   .then((data) => {
      //     console.log(data); // 10
      //     return 20; // This value will be passed to the next .then()
      //   })
      //   .then((data) => {
      //     console.log(data); // 20
      //   });

      // // ==========================================================
      // // Example 3: Handling rejections and returning values
      // // ==========================================================
      // //
      // const p = new Promise((resolve, reject) => {
      //   reject(3);
      // });

      // p.then(
      //   () => {
      //     // This callback is skipped because the promise was rejected.
      //     return 4;
      //   },
      //   // Since the PromiseState is "rejected", this second callback is executed.
      //   (err) => {
      //     console.log(err); // 3
      //     // Returning a normal value automatically creates a fulfilled promise with that value.
      //     // (It's like calling resolve(20).)
      //     return "Hello";
      //   }
      // ).then((data) => {
      //   // Receives the fulfilled value from the previous .then().
      //   console.log(data); // Hello
      // });

      // // ==========================================================
      // // Example 4: Returning a Promise
      // // ==========================================================
      // //

      // const p = new Promise((resolve, reject) => {
      //   reject(3); // Promise immediately rejected with value 3
      // });

      // const p2 = new Promise((resolve, reject) => {
      //   resolve("Success."); // pending → fulfilled
      // });

      // // Case 1: Returning a fulfilled promise inside .then()
      // const p3 = p
      //   .then(
      //     null, // No onFulfilled handler, skip it
      //     (err) => {
      //       console.log(err); // 3

      //       // Returning another promise (p2)
      //       // The next .then() will wait for p2 to settle.
      //       // Since p2 is fulfilled, the next onFulfilled callback will run.
      //       return p2;
      //     }
      //   )
      //   .then((data) => {
      //     console.log(data); // "Success."
      //   });

      // // console.log(p3); // A Promise that will eventually be fulfilled with "Success."

      // // Case 2: Returning a rejected promise inside .then()
      // const p4 = p
      //   .then(null, (err) => {
      //     // How to create rejected promise:
      //     // #1: Returning a rejected promise here
      //     // means the next .then() will call its onRejected handler.
      //     return new Promise((resolve, reject) => {
      //       reject("Failed."); // pending → rejected
      //     });

      //     // #2: here to get a rejected promise so the onRejected callback will be executed.
      //     // throw new Error("Failed");
      //     // Similar to
      //     // new Promise((resolve, reject) => {
      //     //   reject("Failed.");
      //     // });
      //     //
      //     // #3：return thenableObj with onRejected call inside then method.
      //     return {
      //       then(onFulfilled, onRejected) {
      //         onRejected(new Error("Failed."));
      //       },
      //     };
      //   })
      //   .then(null, (err) => {
      //     console.log(err); // "Failed."
      //   });

      // // ==========================================================
      // // Example 5: Returning a Thenable
      // // ==========================================================
      // //

      // const p = new Promise((resolve, reject) => {
      //   reject(3);
      // });

      // // thenable object is an object with then method.
      // const thenableObj = {
      //   a: 1000,
      //   b: 3000,
      //   then(onFulfilled, onRejected) {
      //     onFulfilled(this.b);
      //     // onRejected(this.b);
      //   },
      // };

      // p.then(null, (err) => {
      //   console.log(err); // 3

      //   // Three equivalent ways to return the same thing:
      //   // 1️. Explicitly wrap the thenable
      //   // return new Promise((resolve, reject) => {
      //   //   the resolve / reject of the executor is passed to the then of thenableObj.
      //   //   thenableObj.then(resolve, reject);
      //   // });

      //   // 2️. Use built-in Promise.resolve()
      //   // return Promise.resolve(thenableObj);

      //   // 3️. Simply return the thenable directly - this thenable will be wrapped in Promise.
      //   return thenableObj;
      // }).then((data) => {
      //   console.log(data); // 3000
      // });

      // Test:

      const p = new Promise((resolve, reject) => {
        resolve(1); // pending --> fulfilled.
      })
        .then((data) => {
          console.log(data); // 1
          // No return value.
          // return a fulfilled promise with undefined.
          // return new Promise((resolve, reject) => {
          //   resolve(undefined);
          // });
        })
        .then((data) => {
          console.log(data); // undefined
          return 3;
          // return new Promise((resolve, reject) => {
          //   resolve(3);
          // });
        })
        .then((data) => {
          console.log(data); // 3
          return new Promise((resolve, reject) => {
            reject(4); // pending --> rejected.
          });
        })
        .then(null, (err) => {
          console.log(err); // 4
          return {
            then(onFulfilled, onRejected) {
              onFulfilled("Success!");
            },
          };
          // return new Promise((resolve, reject) => {
          //   thenableObj.then(resolve, reject);
          // });
        })
        .then((data) => {
          console.log(data); // Success!
        });
    </script>
  </body>
</html>
