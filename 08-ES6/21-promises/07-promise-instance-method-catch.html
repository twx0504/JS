<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>07-Promise Instance Method: catch</title>
  </head>
  <body>
    <script>
      // catch
      // then(null, (err)=>{})

      const p = new Promise((resolve, reject) => {
        reject("Failed."); // Similar to throw error.
      });

      //   p.catch((err) => {
      //     console.log(err); // Failed.
      //   });

      //   p.then(null, (err) => {
      //     console.log(err); // Failed.
      //   });

      //   p.then(null, (err) => console.log(err)).catch((err) => {
      //     // This is not run.
      //     console.log("hi");
      //     console.log(err);
      //   });

      //   p.then(null, (err) => {
      //     console.log(err);
      //     return new Promise((resolve, reject) => {
      //       reject("Failed again."); // pending --> rejected. It will call the second callback of then method, or the callback of catch method.
      //     });
      //   }).catch((err) => {
      //     // This is executed.
      //     console.log("hi");
      //     console.log(err);
      //   });

      //   p.then((data) => {
      //     // note: in this then, there's no second callback that handles rejected promise.
      //     console.log(data);
      //   }).catch((err) => {
      //     // the error is passed down to catch.
      //     // So, the unhandled error is handled here.
      //     console.log(err);
      //   });

      // Similar to:
      //   p.then(
      //     () => {},
      //     () => {}
      //   );

      // Error Propagation.
      // If the error is not handled, the onFulfilled callback of intermediate then will never run.
      const p1 = p
        .then((data) => {
          // Since the rejected promise is not handled, the onFulfilled will never run.
          console.log(1);
        })
        .then((data) => {
          // Since the rejected promise is not handled, the onFulfilled will never run.
          console.log(2);
        })
        .then((data) => {
          // Since the rejected promise is not handled, the onFulfilled will never run.
          console.log(3);
        })
        .then((data) => {
          // Since the rejected promise is not handled, the onFulfilled will never run.
          console.log(4);
        })
        // catch method will handle the err.
        .catch((err) => {
          console.log(err); // Failed.
          return 1000;
        })
        .then((data) => {
          console.log(data); // 1000
        });

      // Note: catch method can only deal with error BEFORE it. Error thrown within the catch method will have to be handled by the next catch.
    </script>
  </body>
</html>
