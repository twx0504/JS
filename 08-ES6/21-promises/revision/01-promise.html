<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>01-Promise</title>
  </head>
  <body>
    <script>
      //   const p = new Promise((resolve, reject) => {
      //     resolve("hello");
      //     // resolve() does two things.
      //     // 1. change PromiseState
      //     // 2. change PromiseResult.
      //   });
      //   console.log(p);

      //   p.then((data) => console.log(data));

      //   const p2 = new Promise((resolve, reject) => {
      //     reject("Failed.");
      //     // resolve() does two things.
      //     // 1. change PromiseState
      //     // 2. change PromiseResult.
      //     // 3. throw an error.
      //   });
      //   console.log(p2);
      //   p2.catch((err) => console.log(err));

      // Under the hood:
      class MyPromise {
        #state = "pending";
        #result = undefined;
        static #isPromise(p) {
          return p instanceof MyPromise;
        }

        static #isThenable(p) {
          return (
            p !== null && typeof p === "object" && typeof p.then === "function"
          );
        }

        #isFulfilled() {
          return this.#state === "fulfilled";
        }
        #isRejected() {
          return this.#state === "rejected";
        }
        #isPending() {
          return this.#state === "pending";
        }
        constructor(executor) {
          // Note: be aware of this inside function.
          // - arrow function uses outer this.
          // - regular function has different this. You need to pass outer this inside function.
          const resolve = (data) => {
            // only change state when the state is pending.
            if (this.#isPending()) {
              this.#state = "fulfilled";
              this.#result = data;
            }
          };
          const reject = (reason) => {
            // only change state when the state is pending.
            if (this.#isPending()) {
              this.#state = "rejected";
              this.#result = reason;
              // There is similar mechanism like throwing error.
              //   throw new Error(`Uncaught (in promise) ${reason}`);
            }
          };
          executor(resolve, reject);
        }

        then(onFulfilled, onRejected) {
          return new MyPromise((resolve, reject) => {
            const timerId = setInterval(() => {
              if (this.#isFulfilled()) {
                const p = onFulfilled(this.#result);
                // if p is a promise instance or thenable object.
                if (MyPromise.#isPromise(p) || MyPromise.#isThenable(p)) {
                  p.then(resolve, reject);
                  // if p is a promise, we cannot directly resolve, we need to wait until the promise to fulfill.
                  // it is similar to p.then((data)=>{},(err)=>{}) where resolve and reject are function references, and both receive one argument.;
                } else {
                  resolve(p);
                }
                clearInterval(timerId);
              } else if (this.#isRejected()) {
                const p = onRejected(this.#result);
                if (p instanceof MyPromise) {
                  p.then(resolve, reject);
                } else {
                  reject(p);
                }
                clearInterval(timerId);
              }
            }, 50);
          });
        }

        static resolve(val) {
          // val is promise instance.
          if (MyPromise.#isPromise(val)) return val;
          // val is thenable object.
          if (MyPromise.#isThenable(val)) {
            console.log("val is thenable: ", val);
            return new MyPromise((resolve, reject) => {
              val.then(resolve, reject);
            });
          }
          // val is plain value.
          return new MyPromise((resolve) => resolve(val));
        }

        static reject(reason) {
          return new MyPromise((_, reject) => reject(reason));
        }
      }

      //   new Promise((resolve, reject) => {
      //     console.log("test1");
      //     console.log("test2");
      //     console.log("test3");
      //     return resolve(1000);
      //     // the rest of code will not run.
      //     console.log("test4");
      //     console.log("test5");
      //     console.log("test6");
      //   });

      const thenable1 = {
        then(onFulfilled, onRejected) {
          onFulfilled(10);
        },
      };

      const thenable2 = {
        then(_, onRejected) {
          onRejected(new Error("Failed"));
        },
      };

      const p1 = MyPromise.resolve(thenable1);
      console.log(p1);
      const p2 = Promise.resolve(thenable2);
      console.log(p2);
      const p3 = MyPromise.resolve(thenable2);
      console.log(p3);

      
    </script>
  </body>
</html>
