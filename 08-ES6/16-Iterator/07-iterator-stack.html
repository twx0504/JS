<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>07-Iterator - Stack</title>
  </head>
  <body>
    <script>
      class Stack {
        #length; // private property, length of stack
        #data = []; // private property, array to store the member of the stack.
        constructor(len) {
          this.#length = len;
        }
        get length() {
          return this.#length;
        }
        isEmpty() {
          return this.#data.length === 0;
        }
        isFull() {
          return this.#data.length === this.#length;
        }
        push(val) {
          if (this.isFull()) {
            throw new Error("The stack is full.");
          } else {
            this.#data.push(val);
          }
          return this;
        }
        pop() {
          if (this.isEmpty()) {
            throw new Error("The stack is empty.");
          } else {
            return this.#data.pop();
          }
        }
        // private method
        // usually use with for ... of loop. Provide much more flexibility.
        #getIterator() {
          let index = 0;
          const that = this; // we need to store this in that variable.
          // note: this method returns an object.
          return {
            isDone() {
              return index >= that.#data.length;
            },
            next() {
              if (!this.isDone()) {
                return {
                  value: that.#data[index++],
                  done: false,
                };
              } else {
                return {
                  value: undefined,
                  done: true,
                };
              }
            },
          };
        }

        // What we usually expose to users.
        // But this is pretty much limited.
        // It is easy to use.
        // But it cannot use break, continue, return keyword.
        forEach(callback) {
          const iter = this.#getIterator();
          while (!iter.isDone()) {
            callback(iter.next().value);
          }
          //   for (let i = 0; i < this.#data.length; i++) {
          //     callback(this.#data[i], i, this);
          //   }
        }
      }

      const stack = new Stack(10);
      //   stack.length = 1000; // you cannot modify it.
      console.log(stack.length);

      stack.push(1).push(2).push(3).push(4);
      //   stack.pop();
      //   stack.pop();
      //   stack.pop();
      console.log(stack);

      //   const iter = stack.getIterator();
      //   console.log(iter.next());
      //   console.log(iter.next());
      //   console.log(iter.next());
      //   console.log(iter.next());
      //   console.log(iter.next());

      //   while (!iter.isDone()) {
      //     console.log(iter.next().value);
      //   }
      //   console.log(iter.next().value);

      stack.forEach((val) => {
        console.log(val);
      });
    </script>
  </body>
</html>
