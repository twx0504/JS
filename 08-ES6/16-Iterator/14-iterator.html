<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>14-Iterator - Iterator Use Case</title>
  </head>
  <body>
    <script>
      // for...of

      // Array destructuring
      const str = "Hello";
      const [a, b] = str;
      console.log(a, b);

      const iter = str[Symbol.iterator]();
      console.log(iter.next().value);
      console.log(iter.next().value);
      console.log(iter.next().value);
      console.log(iter.next().value);
      console.log(iter.next().value);

      String.prototype[Symbol.iterator] = function () {
        // Comment or Uncomment the following code.
        // Note: this doesn't return the iterator object with next(), the destructuring throws error.
        // console.log("call");

        // Modify the method.
        // Note: this way, the destructuring still working fine, but there's a subtle difference in what we got.
        // Comment or Uncomment the following code.
        let index = 0;
        const that = this;
        return {
          next() {
            if (index < that.length) {
              return {
                // We now only get index, instead of the element of the array.
                value: index++, // We let value represents the index++, instead of arr[index++]
                done: false,
              };
            } else {
              return {
                value: undefined,
                done: true,
              };
            }
          },
        };
      };

      const str2 = "Hello";
      //   const [x, y] = str;
      //   // Uncaught TypeError: Result of the Symbol.iterator method is not an object
      //   console.log(x, y); // 0 1

      console.log([...str2]);
      // Note: if the Symbol.iterator property didn't follow the iterator protocol, the following error is thrown when you try to spread the string into an array.
      // Uncaught TypeError: Result of the Symbol.iterator method is not an object
      // When you modify the Symbol.iterator method, and make it returns indices instead of value.
      // [0, 1, 2, 3, 4]

      Array.prototype[Symbol.iterator] = function () {
        // Comment or Uncomment the following code.
        // Note: this doesn't return the iterator object with next(), the destructuring throws error.
        // console.log("call");

        // Modify the method.
        // Note: this way, the destructuring still working fine, but there's a subtle difference in what we got.
        // Comment or Uncomment the following code.
        let index = 0;
        const that = this;
        return {
          next() {
            if (index < that.length) {
              return {
                // We now only get index, instead of the element of the array.
                value: index++, // We let value represents the index++, instead of arr[index++]
                done: false,
              };
            } else {
              return {
                value: undefined,
                done: true,
              };
            }
          },
        };
      };

      // new Set(iterable)
      const set = new Set([1, 2, 3, 4]); 
      // If the Symbol.iterator of Array is modified but didn't follow the iterator protocol: it throws error.
      // Uncaught TypeError: Result of the Symbol.iterator method is not an object

      // Under the hood:
      //   const set = new Set();
      //   const arr = [1, 2, 3, 4];
      //   const iter2 = arr[Symbol.iterator]();
      //   set.add(iter2.next().value);
      //   set.add(iter2.next().value);
      //   set.add(iter2.next().value);
      //   set.add(iter2.next().value);
      console.log(set);
    </script>
  </body>
</html>
