<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>06-Iterator: External Iterator V4</title>
  </head>
  <body>
    <script>
      // External Iterator
      Array.prototype.getIterator = function () {
        let index = 0;
        const that = this;
        return {
          isDone() {
            // Note: we use "that" because "this" here refers to this {}.
            // return index > that.length - 1;
            return index >= that.length;
          },
          next() {
            if (!this.isDone()) {
              // this refers to this {}.
              // Modify the next return result to an object - which provides better flexibility.
              // Also, we add "done" property to indicate whether this
              return {
                value: that[index++],
                done: false,
              };
            } else {
              return {
                value: undefined,
                done: true,
              };
            }
          },
        };
      };

      const arr = ["a", "b", "c", "d", "e", undefined];
      const iterator = arr.getIterator();
      //   console.log(iterator);
      //   console.log(iterator.next()); // a
      //   console.log(iterator.next()); // b
      //   console.log(iterator.next()); // c
      //   console.log(iterator.next()); // d
      //   console.log(iterator.next()); // e
      //   console.log(iterator.next()); // undefined

      //   while (!iterator.isDone()) {
      //     // we store the object from iterator.next().
      //     const obj = iterator.next();
      //     console.log(obj);
      //     // this obj contains value where we can use for break, continue, return keyword.
      //     // if (obj.value === "d") break; // example.
      //     console.log(obj.value); // to log the value, we access obj via obj.value.
      //   }

      //   console.log(iterator.next());
      //   console.log(iterator.next());
      //   console.log(iterator.next());
      //   console.log(iterator.next());
      //   console.log(iterator.next());
      //   console.log(iterator.next());

      while (!iterator.isDone()) {
        console.log(iterator.next());
      }

      //   {value: 'b', done: false}
      //   {value: 'c', done: false}
      //   {value: 'd', done: false}
      //   {value: 'e', done: false}
      //   {value: undefined, done: false}  // note: done: false and the value: undefined means that undefined is part of the collection member.
      console.log(iterator.isDone()); // true
      console.log(iterator.next()); // {value: undefined, done: true} // note: done: true means the iterator has exhausted all elements and has nothing more to give you.

      const iterator2 = arr.getIterator();
      while (!iterator2.isDone()) {
        const obj = iterator2.next();
        if (obj.value === "b") {
          continue;
        }
        console.log(obj.value);
      }

      // a
      // c
      // d
      // e
      // undefined


      // Access members of a collection sequentially without exposing internal structure. Call next() manually to get each member. The done property indicates whether iteration is complete
      // call next() manually to iterate the next member, use done prop to validate.
      // isDone() checks whether the iterator has finished processing all members.
      // Works with while loops and control flow keywords like continue, break, return, throw.
    </script>
  </body>
</html>
