<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>11-Iterator: for ... of</title>
  </head>
  <body>
    <script>
      const arr = [1, 2, 3, 4, 5];
      const iter = arr[Symbol.iterator](); // generate an iterator.
      console.log(iter[Symbol.iterator](), iter[Symbol.iterator]() === iter); // Array Iterator {} true
      // Similar to while loop we use before.

      // But wait? How come iter (iterator) is able to use with for...of loop?
      // => iter also has access to Symbol.iterator method that called and produced itself (iterator)
      // => that's why it is working fine here.
      // => usually, for built-in objects.
      for (const val of iter) {
        // iter represents iterator
        // val represents iter.next().value
        console.log(val);
      }
      // Iterator is only used once!
      for (const val of iter) {
        // when iter has been used, it cannot be used again. It can only used once.
        console.log(val);
      }

      for (const val of arr) {
        // arr is an iterable.
        // iter represents iterator
        // val represents iter.next().value
        console.log(val);
      }

      // keys, values, entries returns a new array iterator contains keys / values / entries
      // they all works with for ... of
      console.log(arr.keys()); // Array Iterator {}
      for (const key of arr.keys()) {
        console.log(key);
      }
      console.log(arr.values()); // Array Iterator {}
      for (const val of arr.values()) {
        console.log(val);
      }
      console.log(arr.entries()); // Array Iterator {}
      for (const entry of arr.entries()) {
        console.log(entry);
      }

      // Use of destructuring
      for (const [k, v] of arr.entries()) {
        console.log(k, v);
      }

      // SET
      const set = new Set(arr);

      console.log(set.keys()); // SetIterator {1, 2, 3, 4, 5}

      // In set, set.keys & set.values are the same.
      for (const k of set.keys()) {
        // set.keys are alias to the set.values
        console.log(k);
      }
      for (const v of set.values()) {
        console.log(v);
      }
      for (const [k, v] of set.entries()) {
        console.log(k, v);
      }

      // MAP
      const map = new Map([
        ["arr", [1, 2, 3]],
        [
          "obj",
          {
            a: 1,
            b: 2,
          },
        ],
        [
          "fn",
          function () {
            console.log("fn");
          },
        ],
      ]);

      console.log(map[Symbol.iterator]()); // MapIterator {'arr' => Array(3), 'obj' => {…}, 'fn' => ƒ}

      console.log(map.keys()); // MapIterator {'arr', 'obj', 'fn'}
      for (const k of map.keys()) {
        console.log(k);
      }

      console.log(map.values()); // MapIterator {Array(3), {…}, ƒ}
      for (const v of map.values()) {
        console.log(v);
      }

      console.log(map.entries()); // MapIterator {'arr' => Array(3), 'obj' => {…}, 'fn' => ƒ}
      for (const [k, v] of map.entries()) {
        console.log(k, v);
      }

      const s = new Set([1, 2, 3, 4]);

      for (let v of s) {
        console.log(v);
      }

      const m = new Map([
        ["a", 1],
        ["b", 2],
      ]);

      for (let v of m) {
        console.log(v);
      }

      const str = "Hello";
      console.log(new String("Hello")); // you will see string wrapper object contains Symbol.iterator prop.
      for (let v of str) {
        console.log(v);
      }

      function sum() {
        let sum = 0;
        console.log(arguments); // contains Symbol.iterator method!
        for (let v of arguments) {
          console.log(v);
          sum += v;
        }
        return sum;
      }

      console.log(sum(1, 2, 3, 4, 5));

      // Symbol.iterator - is an expression (static property of Symbol that returns a unique symbol (Symbol.iterator))

      
    </script>
  </body>
</html>
