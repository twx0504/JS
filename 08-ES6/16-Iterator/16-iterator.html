<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Iterator - return method</title>
  </head>
  <body>
    <script>
      class DataContainer {
        data = [1, 2, 3, 4];
        [Symbol.iterator]() {
          let index = 0;
          let data = this.data;
          return {
            next() {
              if (index < data.length) {
                return {
                  value: data[index++],
                  done: false,
                };
              } else {
                return {
                  value: undefined,
                  done: true,
                };
              }
            },
            // return method.
            // Called automatically to perform cleanup.
            return(value) {
              console.log(`Iterator closed early with value: ${value}`);
              console.log("Performing cleanup...");
              // cleanup logic...
              return {
                // value - undefined when using break, throw, return
                // if use as iterator.return(value), then value will be the one you passed.
                value: value, // This becomes the "return value" of the early exit
                done: true,
              };

              // Must return object otherwise it will throw the following error:
              // Note: function, array, etc is an object too, and it wont throw error.
              // Uncaught TypeError: Iterator result undefined is not an object
            },

            // Note: throw is not called automatically.
            throw(exception) {
              console.log(`Iterator throws an exception ${exception}`);
              return {
                value: exception,
                done: true,
              };
            },
          };
        }
      }

      for (let v of new DataContainer()) {
        if (v === 2) {
          // break;
          //   continue; // note: return method will not called when we use continue here.
          // throw new Error("1");
          // return (if work with fn)
        }
        console.log(v);
      }

      // Call when we do not completely consume the iterator next method during destructuring.
      const [a, b, c, d] = new DataContainer();
      console.log(a, b, c, d); // 1 2 3 4
      const [p, q, r, s, t] = new DataContainer();
      console.log(p, q, r, s, t); // 1 2 3 4 undefined

      // Usually, return is called automatically by JS engine.
      // The following shows the manual call.
      const iter = new DataContainer()[Symbol.iterator]();
      console.log(iter.return(1000000));
    </script>
  </body>
</html>
